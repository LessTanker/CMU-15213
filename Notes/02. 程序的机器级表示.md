# 1. 历史观点
# 2. 程序编码
```shell
linux> gcc -Og -o p p1.c p2.c 
```
- `gcc`表明采用GCC C编译器。
- `-Og`标识编译器采用简单优化，但仍保持原码与机器码的对应关系。

编译器工作流程
1. 调用C语言预处理器拓展原代码，插入所有用`#include`命令指定的文件，并拓展所有用`#define`声明指定的宏。
2. 编译器产生两个源文件的汇编代码，分别为`p1.s`和`p2.s`。
3. 汇编器讲汇编代码转换成二进制目标代码文件`p1.o`和`p2.o`。需要注意的是，这里并没有填入全局值的地址，比如调用库函数的起点虚拟地址，或者是声明的全局变量等。
4. 最后链接器将两个目标代码文件与实现库函数（例如`printf`）的代码合并，产生最终的可执行代码文件`p`。
## (1) 机器级代码

- 机器代码对C语言隐藏的处理器状态：
	1. 程序计数器（PC，在`x86-64`中用`%rip`表示）给出将要执行的下一条指令地址。
	2. `x86-64`共有16个整数寄存器，每个寄存器64位，用于存储局部变量、函数返回值等信息。包括`rax, rbx, rcx, rdx, rsp, rbp, rsi, rdi, r8~r15`。
	3. 条件码寄存器储存状态信息，实现控制或数据流中的条件变化。
	4. 存在向量寄存器可以存放一个或多个整数或浮点数值。

- 在程序运行的过程中，只有有限的一部分虚拟地址被认为是合法的。这是因为操作系统为程序映射了实际需要的内存区域，并通过虚拟内存以及页表机制限制了访问，从而保证进程间的隔离。
## (2) 代码示例

```C
//mstore.c
long mult2(long, long);

void multstore(long x, long y, long *dest) 
{
	long t = mult2(x, y);
	*dest = t;
}
```
 此时通过指令`gcc -Og -S mstore.c`可以生成文件`mstore.s`但并不做任何工作，此时可以看到`mstore.s`的内容：
 ```asm
 multstore:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbx
	.cfi_def_cfa_offset 16
	.cfi_offset 3, -16
	movq	%rdx, %rbx
	call	mult2@PLT
	movq	%rax, (%rbx)
	popq	%rbx
	.cfi_def_cfa_offset 8
	ret
	.cfi_endproc
.LFE0:
 ```
 这里核心代码是与书上完全一致的，多出来的部分是新版本的`gcc`默认添加了许多调试、安全特性。这时可以通过指令`gcc -Og -c mstore.c`生成二进制格式的目标代码文件`mstore.o`。

如果想要查看机器代码的内容，可以使用反汇编的技术，例如输入指令`objdump -d mstore.o`会产生如下结果：
```asm
mstore.o:     file format elf64-x86-64

Disassembly of section .text:

0000000000000000 <multstore>:
   0:   f3 0f 1e fa             endbr64
   4:   53                          push   %rbx
   5:   48 89 d3                mov    %rdx,%rbx
   8:   e8 00 00 00 00      call   d <multstore+0xd>
   d:   48 89 03                mov    %rax,(%rbx)
  10:   5b                          pop    %rbx
  11:   c3                           ret
```
这里与教材的结果不完全一致仍然是因为`gcc`默认进行了一些优化。由于汇编指令长度不固定，所以对应的机器码长度也不同。根据指令集规则，CPU可以唯一确定某字节代表哪条汇编语句。

利用反汇编生成的汇编代码和`gcc`生成的代码不会完全相同，`gcc`生成的汇编会严格加上大小后缀（`movq`，`addl`），而反汇编则没有。
```C
//main.c
#include <stdio.h>
void multstore(long, long, long*);
int main() {
	long d;
	multstore(2, 3, &d);
	printf("2 * 3 --> %1d\n", d);
	return 0;
}
long mult2(long a, long b) {
	long s= a* b;
	return s;
}
```
添加`main.c`后可通过`gcc -Og -o prog main.c mstore.c`来生成可执行文件`prog`。并使用`objdump -d prog`来实现反汇编。
## (3) 关于格式的注解
# 3. 数据格式
|C 声明|Intel 数据类型|汇编代码后缀|大小(字节)|
|---|---|---|---|
|char|字节|b|1|
|short|字|w|2|
|int|双字|l|4|
|long|四字|q|8|
|char*|四字|q|8|
|float|单精度|s|4|
|double|双精度|l|8|
- 在64位机器中，指针长8字节。
# 4. 访问信息

![](./shots/2.4.0.png)
## (1) 操作数指示符
数据读取
1. 立即数：书写方式是'`$`'后面跟一个整数。
2. 寄存器：表示某个寄存器内存储的内容，用符号$r_a$表示寄存器$a$，用$R[r_a]$ 表示它存储的值。
3. 内存引用：根据计算出来的有效地址访问某个内存位置，用符号$M_b[Addr]$表示对存储在内存中从地址$Addr$开始的$b$个字节。通常省略下标$b$。

寻址方式
- 通用形式为$Imm(r_b, r_i, s)$。
- $Imm$为立即数偏移，$r_b$为基址寄存器，$r_i$为变址寄存器，$s$为变址因子。$s$只能从$1,2,4,8$中选择。
- 有效地址被计算为$Imm+R[r_b]+R[r_i]\cdot s$。
- 其他形式见下表，均为该通用形式的特殊表示

| 格式                 | 操作数值                              | 名称       |
| ------------------ | --------------------------------- | -------- |
| $\$Imm$            | $Imm$                             | 立即数寻址    |
| $r_a$              | $R[r_a]$                          | 寄存器寻址    |
| $Imm$              | $M[Imm]$                          | 绝对寻址     |
| $(r_a)$            | $M[R[r_a]]$                       | 间接寻址     |
| $Imm(r_a)$         | $M[Imm + R[r_a]]$                 | 基址+偏移量寻址 |
| $(r_b, r_i)$       | $M[R[r_b] + R[r_i]]$              | 变址寻址     |
| $Imm(r_b, r_i)$    | $M[Imm + R[r_b] + R[r_i]]$        | 变址寻址     |
| $(, r_i, s)$       | $M[R[r_i] \cdot s]$               | 比例变址寻址   |
| $Imm(, r_i, s)$    | $M[Imm + R[r_i] \cdot s]$         | 比例变址寻址   |
| $(r_b, r_i, s)$    | $M[R[r_b] + R[r_i] \cdot  s]$     | 比例变址寻址   |
| $Imm(r_b, r_i, s)$ | $M[Imm+ R[r_b] + R[r_i] \cdot s]$ | 比例变址寻址   |
## (2) 数据传送指令
`MOV S, D`的作用是将`S`中的数据传送到`D`中，以下是示例：
```asm
movl $0x4050,%eax                        Immediate--Register, 4 bytes
movw %bp,%sp                                 Register--Register,    2 bytes
movb (%rdi,%rcx),%al                      Memory一Register,     1 byte
movb $-17, (%rsp)                           Immediate--Memory,  1 byte
movq %rax,-12(%rbp)                       Register--Memory,     8 bytes
```
## (3) 数据传送示例
考虑如下代码
```C
long exchange(long *xp, long y)
{
	long x = *xp;
	*xp = y;
	return x;
}
```
汇编代码为
```asm
//xp in %rdi, y in %rsi
00000000000011ea <exchange>:
    11ea:       f3 0f 1e fa             endbr64
    11ee:       48 8b 07                mov    (%rdi),%rax
    11f1:       48 89 37                mov    %rsi,(%rdi)
    11f4:       c3                          ret
```
## (4) 压入和弹出栈数据
- 栈指针`%rsp`用于保存栈顶元素的地址

| 指令        | 效果                                       | 描述     |
| --------- | ---------------------------------------- | ------ |
| `pushq S` | R[%rsp] ← R[%rsp] − 8;<br>M[R[%rsp]] ← S | 将四字压入栈 |
| `popq D`  | D ← M[R[%rsp]];<br>R[%rsp] ← R[%rsp] + 8 | 将四字弹出栈 |
# 5. 算术和逻辑操作
| 指令   | 操作数 | 效果        | 描述               |
|--------|--------|-------------|--------------------|
| leaq   | S, D   | D ← &S      | 加载有效地址       |
| INC    | D      | D ← D + 1   | 加 1              |
| DEC    | D      | D ← D - 1   | 减 1              |
| NEG    | D      | D ← -D      | 取负              |
| NOT    | D      | D ← ~D      | 取补              |
| ADD    | S, D   | D ← D + S   | 加                |
| SUB    | S, D   | D ← D - S   | 减                |
| IMUL   | S, D   | D ← D * S   | 乘                |
| XOR    | S, D   | D ← D ^ S   | 异或              |
| OR     | S, D   | D ← D \| S  | 或                |
| AND    | S, D   | D ← D & S   | 与                |
| SAL    | k, D   | D ← D << k  | 左移              |
| SHL    | k, D   | D ← D << k  | 左移（等同于 SAL） |
| SAR    | k, D   | D ← D >> k  | 算术右移（保符号） |
| SHR    | k, D   | D ← D >> k  | 逻辑右移（补 0）  |

- 加载有效地址

```C
long scale(long x, long y, long z)
{
    long t = x +4*y +12* z;
    return t;
}
```
汇编代码如下：
```asm
00000000000011f5 <scale>:
    11f5:       f3 0f 1e fa               endbr64
    11f9:       48 8d 04 b7             lea    (%rdi,%rsi,4),%rax       x + 4*y
    11fd:       48 8d 14 52              lea    (%rdx,%rdx,2),%rdx    z + 2*z = 3*z
    1201:       48 8d 04 90             lea    (%rax,%rdx,4),%rax    
    1205:       c3                            ret
```

- 特殊的算术操作

| 指令        | 效果 (寄存器变化)                                                           | 描述                                          |
| --------- | -------------------------------------------------------------------- | ------------------------------------------- |
| `imulq S` | `R[%rdx]:R[%rax] ← S × R[%rax]`                                      | **有符号**乘法，全宽结果存放在 `%rdx:%rax`               |
| `mulq S`  | `R[%rdx]:R[%rax] ← S × R[%rax]`                                      | **无符号**乘法，全宽结果存放在 `%rdx:%rax`               |
| `cqto`    | `R[%rdx]:R[%rax] ← sign-extend(R[%rax])`                             | 把 `%rax` 符号扩展成 128 位，写入 `%rdx:%rax`（除法前置操作） |
| `idivq S` | `R[%rax]←(R[%rdx]:R[%rax]) mod S`<br>`R[%rdx]←(R[%rdx]:R[%rax]) ÷ S` | **有符号**除法，商在 `%rax`，余数在 `%rdx`              |
| `divq S`  | `R[%rax]←(R[%rdx]:R[%rax]) mod S`<br>`R[%rdx]←(R[%rdx]:R[%rax]) ÷ S` | **无符号**除法，商在 `%rax`，余数在 `%rdx`              |

对于代码
```C
#include <inttypes.h>
typedef unsigned __int128 uint128_t;

void store_uprod(uint128_t *dest, uint64_t x, uint64_t y)
{
    *dest = x * (uint128_t)y;
}
```
生成的汇编语句如下,除法语句也类似
```asm
00000000000011d8 <store_uprod>:
    11d8:       f3 0f 1e fa             endbr64
    11dc:       48 89 f0                 mov    %rsi,%rax
    11df:       48 f7 e2                 mul    %rdx
    11e2:       48 89 07                mov    %rax,(%rdi)
    11e5:       48 89 57 08           mov    %rdx,0x8(%rdi) 
      #store upper 8 bytes at dest+8
    11e9:       c3                           ret
```
# 6. 控制
## (1) 条件码

常用条件码：
1. `CF`：进位标志，操作使最高位产生了进位。
2. `ZF`：零标志。
3. `SF`：符号标志，操作得到负数。
4. `OF`：溢出标志，操作导致补码溢出。

对于`t = a + b`，根据以下表达式设置条件码：
- `CF = (unsigned)t < (unsigned)a`
- `ZF = (t == 0)`
- `SF = (t < 0)`
- `OF = ((a < 0) == (b < 0)) && ((t < 0) != (a < 0))`

指令`CMP S1. S2`的结果基于`S2-S1`，`TEST S1, S2`基于`S1&S2`，只设置条件码，不改变任何寄存器的值。
## (2) 访问条件码

`SET`指令会根据某些条件码的某种组合，将某字节设置为0或1。`SET`指令的后缀表示不同的条件，而不是操作数的大小。下表是一个计算`long`类型的C语言表达式`a < b`的指令序列：

| 指令        | 效果                                  | 含义（中文）       |
| --------- | ----------------------------------- | ------------ |
| `sete D`  | $D\leftarrow ZF$                    | 相等 / 零       |
| `setne D` | $D\leftarrow -ZF$                   | 不等 / 非零      |
| `sets D`  | $D\leftarrow SF$                    | 负数           |
| `setns D` | $D\leftarrow -SF$                   | 非负数          |
| `setg D`  | $D\leftarrow -(SF\oplus OF)\& -ZF$  | 大于（有符号 >）    |
| `setge D` | $D\leftarrow -(SF\oplus OF)$        | 大于等于（有符号 ≥）  |
| `setl D`  | $D\leftarrow SF\oplus OF$           | 小于（有符号 <）    |
| `setle D` | $D\leftarrow (SF\oplus OF) \lor ZF$ | 小于等于（有符号 ≤）  |
| `seta D`  | $D\leftarrow -CF \& -ZF$            | 超过（无符号 >）    |
| `setae D` | $D\leftarrow -CF$                   | 超过或相等（无符号 ≥） |
| `setb D`  | $D\leftarrow CF$                    | 低于（无符号 <）    |
| `setbe D` | $D \leftarrow CF\lor ZF$            | 低于或相等（无符号 ≤） |

具体使用如下：
```asm
#int comp(data_t a, data_t b)
#a in %rdi, b in %rsi
1 comp: 
2    cmpq %rsi, %rdi              #compare a:b
3    setl %al                           #Set low-order byte of %eax to 0 or 1
4    movzbl %al, %eax            #Clear rest of %eax(and rest of %rax)
5    ret
```
## (3) 跳转指令

```asm
	movq $0, %rax            #Set %rax to 0
	jmp .L1                        #Goto L1
	movq (%rax), %rdx     #Null pointer dereference(skipped)
.L1:
	popq %rdx                  #Jump target
```
这里的`movq (%rax), %rdx`永远不会被执行到。

跳转目的地址的读取：
1. `jmp *%rax`：指令用寄存器`%rax`中的值作为跳转目标。
2. `jmp *(%rax)`：指令以`%rax`中的值作为读地址，从内存中读出该跳转目标。

| 指令           | 同义名  | 跳转条件             | 描述            |
| ------------ | ---- | ---------------- | ------------- |
| jmp Label    |      | 1                | 直接跳转          |
| jmp *Operand |      | 1                | 间接跳转          |
| je Label     | jz   | ZF               | 相等/零          |
| jne Label    | jnz  | ~ZF              | 不相等/非零        |
| js Label     |      | SF               | 负数            |
| jns Label    |      | ~SF              | 非负数           |
| jg Label     | jnle | ~(SF ^ OF) & ~ZF | 大于 (有符号>)     |
| jge Label    | jnl  | ~(SF ^ OF)       | 大于或等于 (有符号>=) |
| jl Label     | jnge | SF ^ OF          | 小于 (有符号<)     |
| jle Label    | jng  | (SF ^ OF) \| ZF  | 小于或等于 (有符号<=) |
| ja Label     | jnbe | ~CF & ~ZF        | 超过 (无符号>)     |
| jae Label    | jnb  | ~CF              | 超过或相等 (无符号>=) |
| jb Label     | jnae | CF               | 低于 (无符号<)     |
| jbe Label    | jna  | CF \| ZF         | 低于或相等 (无符号<=) |
## (4) 跳转指令的编码

原始汇编代码
```asm
1      movq   %rdi, %rax
2      jmp    .L2
3 .L3:
4      sarq   %rax
5 .L2:
6      testq  %rax, %rax
7      jg     .L3
8  rep; ret
```
反汇编产生的代码
```asm
 0: 48 89 f8             mov   %rdi,%rax
 3: eb 03                  jmp   8 <loop+0x8>
 5: 48 d1 f8              sar   %rax
 8: 48 85 c0             test  %rax,%rax
 b: 7f f5                   jg    5 <loop+0x5>
 d: f3 c3                  repz retq
```
1. `0x3: eb 03`
    - `eb` 表示短跳 (short jump)，操作数是 1 字节带符号偏移量。
    - `03` 就是+3。
    - 规则：目标地址 = 下一条指令地址 + 偏移量。
    - 下一条指令地址 = `0x5`（`sar` 的位置）。
    - 所以：目标地址 = `0x5 + 3 = 0x8`，跳到 `test` 指令。
2. `0xb: 7f f8`
    - `7f` 表示`jg`，后面操作数`f8`是1字节带符号偏移。
    - `f8`是补码表示，十进制是`-8`。
    - 下一条指令地址 = `0xd`（`ret`的位置）。
    - 所以：目标地址 = `0xd + (-8) = 0x5`，跳回`sar`。
## (5) 用条件控制来实现条件分支

Ex.将如下汇编代码转换成C语言代码
```asm
#long test (long x, long y, long z)
# x in %rdi, y in %rsi , z in %rdx
test:
    leaq    (%rdi,%rsi), %rax  
    addq    %rdx, %rax   
    cmpq    $-3, %rdi        
    jge     .L2                 
    cmpq    %rdx, %rsi         
    jge     .L3
    movq    %rdi, %rax          
    imulq   %rsi, %rax
    ret
.L3:                            
    movq    %rsi, %rax
    imulq   %rdx, %rax
    ret
.L2:
    cmpq    $2, %rdi            
    jle     .L4
    movq    %rdi, %rax         
    imulq   %rdx, %rax
    ret
.L4:                            
    ret
```

```C
long test(long x, long y, long z)
{
	long val= x + y + z ;
	if (x < -3) {
		if (y < z)
			val= x * y;
		else
			val= y * z;
	} 
	else if (x > 2)
		val= x * z;
	return val;
}
```
## (6) 用条件传送来实现条件分支

- 由于现代CPU采用流水线设计，当程序需要分支预测时，预测错误会造成相当严重的惩罚，即使程序性能下降。而使用条件传送技术可以有效缓解这种惩罚，使控制流不依赖于数据，控制器更容易使流水线是满的。
- 下表是常用的条件传送指令，当传送条件满足时，指令将原值S复制到目的R。

| 指令     | 同义名   | 描述                       |
|----------|----------|----------------------------|
| `cmove`  | `cmovz`  | 相等/零                    |
| `cmovne` | `cmovnz` | 不相等/非零                |
| `cmovs`  |          | 负数                       |
| `cmovns` |          | 非负数                     |
| `cmovg`  | `cmovnle`| 大于（有符号 >）           |
| `cmovge` | `cmovnl` | 大于或等于（有符号 >=）    |
| `cmovl`  | `cmovnge`| 小于（有符号 <）           |
| `cmovle` | `cmovng` | 小于或等于（有符号 <=）    |
| `cmova`  | `cmovnbe`| 超过（无符号 >）           |
| `cmovae` | `cmovnb` | 超过或相等（无符号 >=）    |
| `cmovb`  | `cmovnae`| 低于（无符号 <）           |
| `cmovbe` | `cmovna` | 低于或相等（无符号 <=）    |
```C
long absdiff(long x, long y)
{
    long result;
    if(x < y)
        result = y -x;
    else
        result = x - y;
    return result;
}
```
这段代码在`-Og`的优化级别下仍然是条件控制，当优化级别`-O1`及以上的时候会编译成下面的形式：
```asm
0000000000000035 <absdiff>:
  35:   f3 0f 1e fa             endbr64
  39:   48 89 f2                mov    %rsi,%rdx
  3c:   48 29 fa                 sub    %rdi,%rdx
  3f:   48 89 f8                 mov    %rdi,%rax
  42:   48 29 f0                sub    %rsi,%rax
  45:   48 39 f7                cmp    %rsi,%rdi
  48:   48 0f 4c c2            cmovl  %rdx,%rax
  4c:   c3                           ret
```

>需要注意的是，不是所有的情况都可以使用条件传送，因为条件传送会对`then-expr`和`else-expr`两条表达式都求值。

```C
long cread(long *xp)
{
	return (xp ? *xp : 0);
}
```
这段C语言代码就不能采用条件传送来编译。
## (7) 循环

`while`循环
```C
long fact_do(long n)
{
    long result = 1;
    do {
        result*= n;
        n = n-1;
    } while (n > 1) ;
    return result;
}
```
汇编代码如下
```asm
0000000000000000 <fact_do>:
   0:   f3 0f 1e fa                 endbr64
   4:   b8 01 00 00 00          mov    $0x1,%eax
   9:   48 0f af c7                imul   %rdi,%rax
   d:   48 83 ef 01                sub    $0x1,%rdi
  11:   48 83 ff 01                cmp    $0x1,%rdi
  15:   7f f2                         jg     9 <fact_do+0x9>
  17:   c3                              ret
```
---
`for`循环的格式大致可以看作
```C
for(init-expr;test-expr;update-expr)
	body-statement;
```
与这种写法的`while`循环是完全等价的
```C
init-expr;
while(test-expr){
	body-statement;
	update-expr;
}
```
## (8) switch语句
```C
void switch_eg(long x, long n, long *dest) {
    long val;
    switch (n) {
        case 100:                 
            val = 13 * x;
            break;
        case 102:                
            x = x + 10;  //fall through         
        case 103:                 
            val = x + 11;
            break;
        case 104:                 
            val = x * x;
            break;
        default:                  
            val = 0;
    }
    *dest = val;                  
}
```
汇编代码会生成一份跳转表，索引由`%rsi`寄存器给出，该寄存器存储`index`的值。
```asm
switch_eg:
    subq    $100, %rsi          # index = n - 100
    cmpq    $6, %rsi
    ja      .Ldef               # if index > 6 → default
    jmp     *.L4(,%rsi,8)       # 跳转表[j]

# case 100 → val = 13*x
.L3:                            # loc_A
    leaq    (%rdi,%rdi,2), %rax # rax = 3x
    leaq    (%rdi,%rax,4), %rdi # rdi = x + 4*(3x) = 13x
    jmp     .Ldone

# case 102 → x+10; fall through 103
.L5:                            # loc_B
    addq    $10, %rdi
.L6:                            # loc_C (103)
    addq    $11, %rdi           # val = x+11
    jmp     .Ldone

# case 104 / 106 → x*x
.L7:                            # loc_D
    imulq   %rdi, %rdi
    jmp     .Ldone

# default
.Ldef:                          # loc_def
    movl    $0, %edi

# 公共出口
.Ldone:
    movq    %rdi, (%rdx)        # *dest = val
    ret

#Jump Table   
.section .rodata
.align 8
.L4:
    .quad .L3     # index=0 (n=100) → loc_A
    .quad .Ldef   # index=1 (n=101) → default
    .quad .L5     # index=2 (n=102) → loc_B
    .quad .L6     # index=3 (n=103) → loc_C
    .quad .L7     # index=4 (n=104) → loc_D
    .quad .Ldef   # index=5 (n=105) → default
    .quad .L7     # index=6 (n=106) → loc_D
```
# 7. 过程
- 当`x86-64`过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间，这个部分称为过程的栈帧。
- 栈帧是函数运行时在栈上分配的固定/动态空间，用于保存返回地址、寄存器、局部变量和参数，保证函数调用和返回的状态管理，寄存器优化可以让部分函数完全不使用栈帧。
![](./shots/2.7.0.png)

---

Ex.函数 `procprob` 有4 个参数：`u`,`a`,`v`,`b`，每个参数要么是一个有符号数，要么是一个指向有符号数的指针，并且这些数大小不一样。函数体如下：
```C
*U += a; 
*V += b; 
return sizeof(a) + sizeof(b);
```
编译结果（`x86-64`）：
```asm
procprob:
    movslq  %edi, %rdi        # (1)
    addq    %rdi, (%rdx)      # (2)
    addb    %sil, (%rcx)      # (3)
    movl    $6, %eax          # (4)
    ret
```

答案为`long *u; int a; short b; signed char v;`或`long *u; short b; int a; signed char *v;`

---

 - 寄存器`%rbx,%rbp`以及`%r12~%r15`被划分为被调用者保存寄存器，当过程P调用过程Q时，Q必须保存这些寄存器的值，保证它们的值在Q返回到P时与Q被调用时是一致的。
```C
long rfact(long n)
{
	long result;
	if(n <= 1)
		result = 1;
	else 
		result= n * rfact(n-1) ;
	return result ;
}
```
汇编代码为
```asm
rfact:
    pushq   %rbx               ; 保存被调用者保存寄存器 %rbx
    movq    %rdi, %rbx      ; 将参数 n 存储到被调用者保存寄存器
    movl    $1, %eax          ; 设置返回值 = 1
    cmpq    $1, %rdi          ; 比较 n 和 1
    jle     .L35                   ; 如果 n <= 1，跳转到结束标签
    leaq    -1(%rdi), %rdi   ; 计算 n-1
    call    rfact                  ; 递归调用 rfact(n-1)
    imulq   %rbx, %rax      ; 将结果乘以 n
.L35:                                 ; 结束标签
    popq    %rbx                ; 恢复 %rbx 寄存器
    ret                              ; 函数返回
```
# 8. 数组分配和访问

- 假设`E`是一个`int`类型的数组，那么`movl (%rdx, %rcx, 4), %eax`会读取`E[i]`并把结果存储到`%eax`中。

| 表达式    | 汇编指令                       | 解释              |
| ------ | -------------------------- | --------------- |
| E\[1]  | `movl (%rdx,%rcx,4), %eax` | 将存储在数组里的值放进%eax |
| &E\[2] | `leaq 8(%rdx), %rax`       | 将E\[2]的地址放进%rax |

---

- 考虑二维数组`int A[5][3]`，想要访问`A[i][j]`，假设`x_A, i, j`分别存储在`%rdi, %rsi, %rdx`，则可以通过如下方式将`A[i][j]`复制到`%eax`中
```asm
1        leaq (%rsi, %rsi, 2), %rax         Compute 3i
2       leaq (%rdi, %rax, 4), %rax        Compute x_A + 12i
3       movl (%rax, %rdx, 4), %eax      Read from M[x_A + 12i + 4j]
```

---

矩阵内积计算代码优化
```C
int fix_prod_ele (fix_matrix A, fix_matrix B, long i, long k) {
    long j;
    int result = 0;
    for (j = 0; j < N; j++)
        result += A[i][j] * B[j][k];
    return result;
}

int fix_prod_ele_opt(fix_matrix A, fix_matrix B, long i, long k) {
    int *Aptr = &A[i][0];    /* 指向 A 的第 i 行开头 */
    int *Bptr = &B[0][k];    /* 指向 B 的第 k 列开头 */
    int *Bend = &B[N][k];    /* 指向 B 的第 k 列的结束位置 */
    int result = 0;
    do {
        result += *Aptr * *Bptr;
        Aptr++;        /* A 向右移动 1 个元素 */
        Bptr += N;     /* B 向下移动 1 行 */
    } while (Bptr != Bend);
    return result;
}
```
# 9. 异质的数据结构

- 结构体的所有组成部分都放在内存中一段连续的地址空间中，指向结构的指针就是结构体第一个字节的地址，编译器通过字节偏移指引对结构元素的引用。
- 一个联合的总大小等于其最大字段的大小，联合中不同字段的使用是互斥的，将字段声明为联合而不是结构会节省分配内存空间。
- 数据对齐：任何K字节的基本对象的地址必须是K的倍数，通常来说保持数据对齐能够提高效率，但不会影响程序的行为。
# 10. 将控制和数据结合起来
## (1) GDB调试器

| GDB指令                                                                               | 描述                                                                 |
| ----------------------------------------------------------------------------------- | ------------------------------------------------------------------ |
| 开始和停止<br/>    quit<br/>    run<br/>    kill                                         | <br/>退出GDB<br/>运行程序<br/>停止程序                                       |
| 断点<br/>    break multstore<br/>    break * 0x400540<br/>    delete 1<br/>    delete | <br/>在函数multstore入口处设置断点<br/>在地址0x400540处设置断点<br/>删除断点1<br/>删除所有断点 |
| 执行<br/>    stepi<br/>    stepi 4<br/>    continue<br/>    finish                    | <br/>执行1条指令<br/>执行4条指令<br/>继续执行<br/>执行到当前函数返回                      |
| 检查代码<br/>    disas multstore<br/>    disas 0x400540 0x40054d                        | <br/>反汇编函数multstore<br/>反汇编指定地址范围内的代码                              |
| 检查数据<br/>    print $rax<br/>    print /x $rip <br/>    x/2g 0x7fffffffe818          | <br/>以十进制输出%rax的内容<br/>以十六进制输出程序计数器的值<br/>检查从地址0x7fffffffe818开始的双字 |
| 其他<br/>    info frame<br/>    info registers<br/>    help                           | <br/>有关当前栈帧的信息<br/>所有寄存器的值<br/>获取有关GDB的信息                          |
## (2) 内存越界引用和缓存区溢出
```C
char *gets(char *s)
{
    int c;
    char *dest = s;
    while ((c = getchar()) != '\n' && c != EOF)
        *dest++ = c;
    if (c == EOF && dest == s)
        return NULL;
    *dest++ = '\0'; /* Terminate string */
    return s;
}
void echo() 
{
    char buf[8]; /* May too small! */
    gets(buf);
    puts(buf);
}
```
这里当我们故意将缓存区设置的非常小——只有8字节长时，任何长度超过7个字符的写入都会导致写越界。下面是echo函数的汇编代码
```asm
echo:
    subq    $24, %rsp       ; 在栈上分配24字节
    movq    %rsp, %rdi     ; 计算buf作为%rsp
    call    gets                  ; 调用gets
    movq    %rsp, %rdi     ; 计算buf作为%rsp
    call    puts                  ; 调用puts
    addq    $24, %rsp       ; 释放栈空间
    ret                             ; 返回
```
注意这里栈为`echo`函数分配了24字节的空间，而`buf`实际只需要16字节来存储，多出来的8字节是为了数据对齐。只要用户的写入不超过7个字符（最后一位要用作'\0‘），`gets`函数返回的字符串就可以放进为`buf`分配的空间中。但随着字符串变长，下面的信息就会被破坏：

| 输入的字符数量 | 附加的被破坏的状态    |
| ------- | ------------ |
| 0~7     | 无            |
| 9~23    | 未被使用的栈空间     |
| 24~31   | 返回地址         |
| 32+     | caller中保存的状态 |
缓存区溢出可能导致程序执行其本不会执行到的函数，这也是一种常见的系统安全攻击的方法。比如可以给程序输入一个字符串，该字符串包含一些可执行代码的字节编码，称为攻击代码。或者用一些字节用一个指向攻击代码的指针覆盖返回地址，那么执行`ret`指令就会跳转到攻击代码。
## (3) 对抗缓存区溢出攻击
### 1. 栈随机化
在程序开始时，在栈上分配一段0~n字节之间的随机大小的空间，程序不使用这段空间，但它会导致程序每次执行时后续的栈位置发生变化。还有一种技术称为地址空间布局随机化，能做到每次运行程序时，程序代码、库代码、栈、全局变量、堆数据等都会加载到内存的不同区域。
### 2. 栈破坏检测
在栈帧中任何局部缓冲区与栈状态之间存储一个特殊的canary值，也称为哨兵，是在程序每次运行时随机产生的。在恢复寄存器状态和从函数返回之前，程序检查canary是否被改变，如果被改变则程序异常终止。
```asm
movq %fs:40, %rax   ; 读取 TLS 中 canary
movq %rax, 8(%rsp)  ; 存到栈上
...
movq 8(%rsp), %rax
xorq %fs:40, %rax   ; 比较
je ok               ; 相等正常
call __stack_chk_fail ; 被修改触发报错
```
攻击者无法预测或修改`TLS`中的canary，溢出必触发检查，难以仅改变函数行为而不覆盖返回地址。
### 3. 限制可执行代码区域
可以限制哪些内存区域能存放可执行代码。在典型的程序中，只有保存编译器产生的代码的那部分内存才需要是可执行的，其他部分可以限制为只允许读和写。
## (4) 支持变长栈帧
- 汇编中首先保存旧帧指针 `%rbp` 并设置新的 `%rbp` 作为栈帧基准，然后用 `subq` 根据运行时计算的大小动态调整 `%rsp` 分配局部变量空间。
- 局部变量访问相对 `%rbp` 的偏移固定，而 `%rsp` 在函数执行过程中可能随数组大小和循环操作不断变化。
```C
long vframe(long n, long idx, long *q) {
    long i;
    long *p[n];  // 变长数组(VLA)，大小在运行时确定
    p[0] = &i;
    for (i = 1; i < n; i++)
        p[i] = q;
    return *p[idx];
}
```
- 初始化循环中，通过 `%rax` 遍历数组并存储元素，每次迭代 `%rsp` 可能变化，但 `%rbp` 始终稳定，保证局部变量和参数访问正确。
- 函数退出时，`leave` 指令恢复 `%rbp` 和 `%rsp`，完成栈帧回收。
- 帧指针在变长栈帧中起到固定访问基准的作用，使编译器能够安全访问局部变量和参数，同时支持调试和栈回溯。
```asm
vframe:
  pushq  %rbp                                     // Save old %rbp
  movq   %rsp, %rbp                           // Set frame pointer
  subq   $16, %rsp                              // Allocate space for i (%rsp = s₁)
  leaq   22(%rdi,8), %rax
  andq   $-16, %rax
  subq   %rax, %rsp                            // Allocate space for array p (%rsp = s₂)
  leaq   7(%rsp), %rax
  shrq   $3, %rax
  leaq   0(,%rax,8), %r8                      // Set %r8 to &p[0]
  movq   %r8, %rcx                             // Set %rcx to &p[0] (%rcx = p)
  . . .

.L3:                                                    // loop:
  movq   %rdx, (%rcx,%rax,8)            // Set p[i] to q
  addq   $1, %rax                               // Increment i
  movq   %rax, -8(%rbp)                    // Store on stack

.L2:
  movq   -8(%rbp), %rax                    // Retrieve i from stack
  cmpq   %rdi, %rax                           // Compare i:n
  jl     .L3                                           // If <, goto loop
  . . .

  leave                                              // Restore %rbp and %rsp
  ret                                                 // Return
```
# 11. 浮点代码
- `double f1(int x, double y, long z)`会将`x, y, z`分别存放在`%edi, %xmm0, %rsi`中。
- 汇编指令和整数处理十分相似，在这里不详细整理，不然笔记就会十分繁琐。
# 12. 小结
- 本章对应CMU-15213的bomblab以及attacklab，书上内容非常多，堪称CSAPP这本书第一大章，本人于2025.8.22~2025.8.29整理完成该章笔记。
