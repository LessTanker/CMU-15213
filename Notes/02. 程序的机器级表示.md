# 1. 历史观点
# 2. 程序编码
```shell
linux> gcc -Og -o p p1.c p2.c 
```
- `gcc`表明采用GCC C编译器。
- `-Og`标识编译器采用简单优化，但仍保持原码与机器码的对应关系。

编译器工作流程
1. 调用C语言预处理器拓展原代码，插入所有用`#include`命令指定的文件，并拓展所有用`#define`声明指定的宏。
2. 编译器产生两个源文件的汇编代码，分别为`p1.s`和`p2.s`。
3. 汇编器讲汇编代码转换成二进制目标代码文件`p1.o`和`p2.o`。需要注意的是，这里并没有填入全局值的地址，比如调用库函数的起点虚拟地址，或者是声明的全局变量等。
4. 最后链接器将两个目标代码文件与实现库函数（例如`printf`）的代码合并，产生最终的可执行代码文件`p`。
## (1) 机器级代码

- 机器代码对C语言隐藏的处理器状态：
	1. 程序计数器（PC，在`x86-64`中用`%rip`表示）给出将要执行的下一条指令地址。
	2. `x86-64`共有16个整数寄存器，每个寄存器64位，用于存储局部变量、函数返回值等信息。包括`rax, rbx, rcx, rdx, rsp, rbp, rsi, rdi, r8~r15`。
	3. 条件码寄存器储存状态信息，实现控制或数据流中的条件变化。
	4. 存在向量寄存器可以存放一个或多个整数或浮点数值。

- 在程序运行的过程中，只有有限的一部分虚拟地址被认为是合法的。这是因为操作系统为程序映射了实际需要的内存区域，并通过虚拟内存以及页表机制限制了访问，从而保证进程间的隔离。
## (2) 代码示例

```C
//mstore.c
long mult2(long, long);

void multstore(long x, long y, long *dest) 
{
	long t = mult2(x, y);
	*dest = t;
}
```
 此时通过指令`gcc -Og -S mstore.c`可以生成文件`mstore.s`但并不做任何工作，此时可以看到`mstore.s`的内容：
 ```shell
 multstore:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbx
	.cfi_def_cfa_offset 16
	.cfi_offset 3, -16
	movq	%rdx, %rbx
	call	mult2@PLT
	movq	%rax, (%rbx)
	popq	%rbx
	.cfi_def_cfa_offset 8
	ret
	.cfi_endproc
.LFE0:
 ```
 这里核心代码是与书上完全一致的，多出来的部分是新版本的`gcc`默认添加了许多调试、安全特性。这时可以通过指令`gcc -Og -c mstore.c`生成二进制格式的目标代码文件`mstore.o`。

如果想要查看机器代码的内容，可以使用反汇编的技术，例如输入指令`objdump -d mstore.o`会产生如下结果：
```shell
mstore.o:     file format elf64-x86-64

Disassembly of section .text:

0000000000000000 <multstore>:
   0:   f3 0f 1e fa             endbr64
   4:   53                          push   %rbx
   5:   48 89 d3                mov    %rdx,%rbx
   8:   e8 00 00 00 00      call   d <multstore+0xd>
   d:   48 89 03                mov    %rax,(%rbx)
  10:   5b                          pop    %rbx
  11:   c3                           ret
```
这里与教材的结果不完全一致仍然是因为`gcc`默认进行了一些优化。由于汇编指令长度不固定，所以对应的机器码长度也不同。根据指令集规则，CPU可以唯一确定某字节代表哪条汇编语句。