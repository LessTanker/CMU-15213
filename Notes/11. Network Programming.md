# 11.1 客户端-服务器编程模型

![[11.1.0.png]]
# 11.2 网络

>对于主机而言，网络只是一种I/O设备，是数据源与数据接收方
## 1. 局域网

>物理上而言，网络是一个按照地理远近组成的层次系统，最底层是局域网（LAN）。以太网是实现局域网的一种有效技术。
### (1) 集线器
- 一个以太网段包括集线器与一些电缆，每根电缆拥有相同的最大位带宽，通常是100Mb/s-1Gb/s。一端连接主机的适配器，另一端连接到集线器的一个端口。集线器会将从某一个端口收到的信息复制到其他所有端口上，从而使每个主机共享这些信息。
- 一台主机发送一段位（帧）到集线器，每个帧都包含固定数量的header位，用于标识此帧的源和目的地址等，其余位为数据的有效载荷（payload）。这里每个主机都能看到这个帧，但只有目的主机实际接收。
### (2) 网桥
- 网桥可以连接多段以太网段，组成较大的局域网，下面是示意图：

![[11.2.1.1.png]]
- 如果从A发送到B，那么信息只会被复制到AB所在的那个集线器，与该集线器连接的主机会接收到该信息，桥X连接的其他集线器以及其余的网桥都不会发送该信息。
- 但如果是从A发送到C，那么除了A和C所在的集线器所连接的主机，其余所有集线器连接的主机都不会被发送该信息。
## 2. 广域网
- 计算机网络发展早期，不同的局域网由于种种原因会出现不兼容的问题，所以产生了路由器（router）将其连接起来。
- 由于不同联网技术（以太网、WiFi、光纤等）采用不同的帧结构，每种帧虽然都会包含控制信息段（源地址、目的地址、长度等），但不同帧的控制信息段的位置、长度、编码方式都不同，这就是导致不兼容的原因。
- 下图则是一个示例，说明路由器如何连接不兼容的局域网：
![[11.2.2.1.png]]
- 解决不兼容的方法：部署在主机和路由器上的协议软件
- 协议软件提供两种基本能力：
	- 命名机制：每台主机至少被分配一种互联网络地址（internet address），这个地址唯一标识这个主机。
	- 传送机制：定义一种统一的“包（packet）”形式，由包头+有效载荷组成。包在不同网络之间保持一致。
## 3. 示例
- 下图展示主机和路由器如何使用互联网协议在不兼容的局域网之间传送数据：
![[11.2.3.1.png]]

详细步骤：
1. 主机A上的客户端发送系统调用，从客户端的虚拟地址空间复制数据到内核缓冲区。
2. 通过主机A上的协议软件在数据前附加包头和LAN1帧头，创建了一个LAN1的帧。
	- LAN1的帧头用于寻址到路由器，而包头用于寻址到主机B。
	- LAN1帧的有效载荷为互联网络包，互联网络包的有效载荷是实际用户数据。
3. LAN1适配器复制该帧到网络上。
4. 帧到达路由器后，路由器上的LAN1适配器将其传送到协议软件。
5. 路由器从包头中提取出目的网络地址，将其作为路由表的索引，确定向哪里转发这个包。随后剥落LAN1的帧头，加上LAN2的帧头，将新帧传送到LAN2适配器。
6. LAN2适配器复制该帧到网络上。
7. 到达主机B后，LAN2适配器从电缆上读到此帧，传送到协议软件。
8. 主机B上的协议软件剥落LAN2帧头以及包头。当服务器进行读取这个数据的系统调用时，协议软件将最后得到的数据复制到服务器的虚拟地址空间。
## 4. 问题
1. 不同网络的最大帧大小不同
	- 不同链路层技术的最大长度限制（MTU）不同，大包可能装不进下一段链路的帧中，需要分片传输。
2. 路由器如何确定转发帧的去向
	- 路由器需要依据包头里涵盖的IP地址来确定下一跳的去向（其他路由器/目标主机），用获得的IP地址查询路由表。
3. 网络拓扑变化时如何通知路由器
	- 路由器转发包时，需要根据路由表决定下一跳，此时如果网络结构变化，原本的下一跳可能失效（链路断开）或存在更快速的路径。可以依靠路由协议自动发现与更新。
4. 网络传输的可靠性问题
	- 链路错误、路由器缓存溢出、网络拥塞等原因都可能导致包丢失，需要检测丢包、重传等方式解决。
# 11.3 全球IP因特网
## 1. IP地址
一个IP地址就是一个32位无符号整数，网络程序将IP存放在下面这个结构体中。
```C
/*IP address structure*/
struct in_addr{
	uint32_t s_addr;//Address in network byte order(big-endian)
};
```
由于在IP地址结构中，地址总是以大端的方式进行存储，而主机一般采用小端的方式，所以在向网络发送数据和接收数据时要进行转换。
- 大端存储： 将数据的高位字节放在低地址，类似人类读取数字的方式（先高位，后低位）。
- 小端存储： 将数据的低位字节放在低地址，更符合CPU处理逻辑（低位先处理）。 

下面是Unix提供的转换函数：
```C
#include <arpa/inet.h>

//Returns: value in network byte order
uint32_t htonl(uint32_t hostlong);
uint16_t htons(uint16_t hostshort);

//Returns: value in host byte order
uint32_t ntohl(uint32_t netlong);
uint16_t ntohs(uint16_t netshort);
```

IP地址通常以点分十进制表示，在Linux系统上可以通过`hostname`命令查看主机的地址。
```bash
linux> hostname -i
127.0.0.1
```

应用程序使用`inet_pton`和`inet_ntop`函数来实现IP地址和点分十进制串的转换：
```C
#include <arpa/inet.h>

//返回：若成功则为1，若src为非法点分十进制地址则为0，若出错则为-1
int inet_pton(AF_INET, const char* src, void* dst);

//返回：若成功则指向点分十进制字符串的指针，若出错则为NULL
const char* inet_ntop(AF_INET,const void* src,char* dst,socklen_t size);
```
- `inet_pton`将一个点分十进制串（src）转换成一个二进制的网络字节顺序的IP地址（dst）。
- `inet_ntop`将一个二进制的网络字节顺序的IP地址（src）转换为它所对应的点分十进制表示，并把得到的以`null`结尾的字符串的最多`size`个字节复制到dst。
## 2. 因特网域名
因特网定义了域名集合和IP地址集合之间的映射，这种映射通过一个叫做DNS（Domain Name System）的数据库来维护。

每台因特网主机都有一个本地定义的域名localhost，这个域名总是映射为回送地址（loopback address）127.0.0.1
```shell
linux> nslookup localhost
Address: 127.0.0.1
```

域名与IP地址之间的关系：
1. 一一映射
2. 多个域名共用同一个IP地址
	- 服务器会根据HTTP请求头的host字段来区分访问的是哪个域名
	- 即当浏览器发送HTTP请求时，请求里会带上域名如www.example.com
3. 多个域名映射到同一组的多个IP地址
4. 某些合法域名没有映射到任何IP地址
## 3. 因特网连接
- 套接字（socket）是网络通信的端点，是应用程序通过网络发送和接收数据的“端口”，是IP地址+端口号（16位整数）的结合。例如，`192.168.1.10:443`表示IP地址为192.168.1.10的主机上端口443这个网络端点。
- 当客户端发起一个连接请求时，客户端套接字地址中的端口是由内核自动分配的，称为临时端口。而服务器套接字地址中的端口通常是某个知名端口，比如Web服务器使用端口80，电子邮件使用端口25。
	- 不同服务器上的端口互不干扰
	- 常用端口号固定
	- 服务器端口数量和用途可变
- 一个连接是由它两端的套接字地址唯一确定的，该套接字对可以由元组表示：`(cliaddr: cliport, servaddr: servport)`
# 11.4 套接字接口
套接字接口（socket interface）是一组用于创建网络应用的函数，它们都与Unix I/O函数结合起来。下图是一份典型的客户端-服务器事务的上下文的套接字接口概述：
![[11.4.0.png]]
## 1. 套接字地址结构
因特网的套接字地址存放在下面的`sockaddr_in`的16字节结构中
```C
/*IP socket address structure */
struct sockaddr_in{
	uint16_t sin_family;            //Protocol family(always AF_INET)
	uint16_t sin_port;               //Port number in network byte order
	struct in_addr sin_addr;     //IP address in network byte order
	unsigned char sin_zero[8];  //Pad to sizeof(struct sockaddr)
};

/*Generic socket address structure(for connect, bind and accept) */
struct sockaddr{
	uint16_t sa_family;              //Protocol family
	char sa_data[14];                 //Address data
};
```
由于历史遗留问题，`sockaddr_in`只支持IPv4这一种形式，还存在`sockaddr_in6`等结构体，所以新设计了`sockaddr`这一结构体作为系统调用统一接受的类型。而在真实使用时，则需要进行强制类型转换，`sin_zero` 也是为了使结构体大小与`sockaddr`保持一致。
## 2. socket函数
```C
#include <sys/types.h>
#include <sys/socket.h>

//Returns: nonegative descriptor if OK, -1 on error
int socket(int domain, int type, int protocol);
//Example
int clinetfd = socket(AF_INET, SOCK_STREAM, 0);
```
- domain：指定协议族（协议域）
    - `AF_INET`：IPv4 网络（32 位 IP 地址）
    - `AF_INET6`：IPv6 网络
    - `AF_UNIX`：本地进程间通信（UNIX 域套接字）
- type：指定套接字类型
    - `SOCK_STREAM`：面向连接的字节流（TCP）
    - `SOCK_DGRAM`：无连接的报文传递（UDP）
- protocol：通常写0，表示由系统根据 domain 和 type 自动选择对应协议（TCP/UDP）。
## 3. connect函数
```C
#include <sys/socket.h>

//Returns: 0 if OK, -1 on error
int connect(int clientfd, const struct sockaddr* addr, socklen_t addrlen);
```
`connect`函数会尝试与套接字地址为`addr`的服务器建立一个因特网连接，其中`addrlen`代表`sizeof(sockaddr_in)`。`connect`函数除非连接成功建立或者发生错误，否则会一直处于阻塞状态。
## 4. bind函数
```C
#include <sys/socket.h>

//Returns: 0 if OK, -1 on error
int bind(int sockfd, const struct sockaddr* addr, socklen_t addrlen);
```
- `bind`函数是把由`socket`函数声明出来的套接字对（即`sockfd`）绑定到主机（多为服务器）的特定端口上面，由服务器负责管理。
- 而`connect`是把由客户端发起的套接字对连接到特定的服务器上，但并不确定连接该服务器的具体端口。
## 5. listen函数
```C
#include <sys/socket.h>

//Returns: 0 if OK, -1 on error
int listen(int sockfd, int backlog);
```
- `sockfd`：服务器之前创建并 `bind()` 过的套接字描述符。
- `backlog`：内核为这个套接字维护的等待连接队列的最大长度。
- 服务器端不调用`listen`函数，客户端发送的`connect`函数就会失败。
## 6. accept函数
```C
#include <sys/socket.h>

//Returns: nonnegative connected descriptor if OK, -1 on error
int accept(int listenfd, struct sockaddr* addr, int *addrlen);
```
当有客户端请求连接（`connect`）时，`accept`函数会：
1. 从`listenfd`的等待队列里取出一个连接请求。
2. 为这个连接生成一个新的套接字`connfd`（已连接描述符）。
3. 在`connfd`和客户端的`clientfd`之间建立一条专用的通信通道。
4. 返回这个`connfd`给服务器程序。

![[11.4.6.1.png]]
 
## 7. 主机和服务的转换
>Linux提供了`getaddrinfo`和`getnameinfo`这两个函数来实现：二进制套接字地址结构和主机名、主机地址、服务名和端口号的字符串表示之间的相互转化。
### (1) getaddrinfo函数
```C
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>

//Returns: 0 if OK, nonzero error code on error
int getaddrinfo(
	const char* host,
	const char* service,
	const struct addrinfo* hints,
	struct addrinfo** results
);

//Returns: nothing
void freeaddrinfo(struct addrinfo* result);

//Returns: error message
const char* gai_strerror(int errorcode);
```

>getaddrinfo会根据输入将所有可能成立的套接字对存入result中，哪个优先socket+connect成功就用哪个进行连接。

```C
struct addrinfo{
	int ai_flags;                             //Hints argument flags
	int ai_family;                           //First arg to socket function
	int ai_socktype;                       //Second arg to socket function
	int ai_protocol;                        //Third arg to socket function
	char* ai_cannoname;                //Canonical hostname
	size_t ai_addrlen;                   //Size of ai_addr struct
	struct sockaddr* ai_addr;       //Ptr to socket address structure
	struct addrinfo* ai_next;        //Ptr to next item in linked list
};
```

函数说明：
1. `addrinfo`结构体：描述一条完整的网络地址信息（包括协议族、套接字类型、协议、实际地址等），可直接用于`socket`创建和`connect`连接。
2. `result`是一个指向`addrinfo`结构的链表，其中每个结构指向一个对应于`host`和`service`的套接字地址结构。
	- 采用链表结构的原因：同一个`host`或`service`可能对应多个可用的地址，`getaddrinfo`函数会将所有的结果全部放进链表。
3. `host/service`：
	- `host`可以为域名如 “www.example.com” ，也可以是IP地址如“192.168.0.1”，还可以为`NULL`。
	- `service`可以是服务名如“http”，“ftp”，此时函数会查询`/etc/services`并映射到端口号，还可以直接使用端口号，或为`NULL`。
4. `hints`：可以对`getaddrinfo`返回的套接字地址列表筛选过滤。如果传入`hints`字段，只能设置以下字段：`ai_family`，`ai_socktype`，`ai_protocol`，`ai_flags`。其他字段必须设置成`0`或`NULL`。在实际应用中，用`memset`将整个结构清空，然后有选择地设置一些字段。
	1. `ai_family`
		- `AF_UNSPEC`（默认）：返回 IPv4 和 IPv6 地址。
		- `AF_INET`：只返回 IPv4 地址。
		- `AF_INET6`：只返回 IPv6 地址。
	2. `ai_socktype`
		- `SOCK_STREAM`：只返回支持TCP的地址。
		- `SOCK_DGRAM`，`SOCK_RAM`等
	3. `ai_flags`
		- `AI_ADDRCONFIG`
			- 只返回当前主机网络接口配置支持的协议族地址。
			- 客户端使用此标识可以避免获取到本地不支持的地址类型。
		- `AI_CANONNAME`：
			- 将`result`所维护的链表中第一个`addrinfo`结构体中的`ai_cannoname`字段指向该`host`的权威主机名。
		- `AI_NUMERICSERV`：强制`service`为端口号。
		- `AI_PASSIVE`
			- 用于监听所有套接字对。
			- `host`设置为`NULL`，得到的地址字段会是通配符地址，即该服务器会接受发送到主机的所有IP地址的请求。
5. `addrinfo`结构体中的字段是不透明的，它们可以直接传送给套接字接口中的函数。满足代码独立于某个特殊版本的IP协议。
### (2) getnameinfo函数
>用于将一个套接字地址结构转换成相应的主机和服务名字符串。

```C
#include <sys/socket.h>
#include <netdb.h>

//Returns: 0 if OK, nonzero error code on error
int getnameinfo(
	const struct sockaddr* sa,
	socklen_t salen,
	char* host,
	size_t hostlen,
	char* service,
	size_t servlen,
	int flags
);
```

函数说明：
1. `sa`指向一个套接字地址结构，里面包含了IP地址和端口号的二进制信息。由于二进制不方便阅读，所以使用`getnameinfo`函数将主机名和端口名称分别存入`host`和`survice`。
2. 如果`getnameinfo`返回非零的错误代码，应用程序可以通过调用`gai_strerror`把它转换为字符串。
3. 参数`flags`是一个位掩码，可以修改默认行为。
	- `NI_NUMERICHOST`：函数默认返回`host`中的域名，设置该标志会使该函数返回一个数字地址字符串。
	- `NI_NUMERICSERV`：函数默认检查`/etc/services`，如果可能，会返回服务名而不是端口名。设置该标志会使该函数跳过查找，简单地返回端口号。
## 8. 套接字接口的辅助函数

>下面这两个函数都不是C标准库自带的函数，而是CSAPP作者自己封装的一个建立客户端socket连接的辅助函数。函数内部实现中像Freeaddrinfo这种大写的，实际上是CSAPP做的一层封装，便于打印报错信息。
### (1) open_clientfd函数
- 客户端通过调用该函数建立与服务器的连接。
- 服务器运行在主机hostname上，并在端口号port上监听连接请求。
```C
#include "csapp.h"

//Returns: descriptor if OK, -1 on error
int open_clientfd(char* hostname, char* post)
{
	int clientfd;
	struct addrinfo hints, *listp, *p;
	
	memset(&hints, 0, sizeof(struct addrinfo));
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_flags = AI_ENUMERICSERV;
	hints.ai_flags |= AI_ADDRCONFIG;
	Getaddrinfo(hostname, port, &hints, &listp);
	
	for(p = listp;p;p = p->ai_next){
		if((clientfd=socket(p->ai_family,p->ai_socktype,p->ai_protocol))<0)
			continue;
		if(connect(clientfd, p->ai_addr, p->ai_addrlen) != -1)
			break;
		Close(clientfd);
	}
	
	Freeaddrinfo(listp);
	if(!p) return -1;
	else
		return clientfd;
}
```
### (2) open_listenfd函数
```C
int open_listenfd(char* port)
{
	struct addrinfo hints, *listp, *p;
	int listenfd, optval = 1;
	
	memset(&hints, 0, sizeof(struct addrinfo));
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG;
	hints.ai_flags |= AI_NUMERICSERV;
	Getaddrinfo(NULL, port, &hints, &listp);
	
	for(p = listp;p;p = p->ai_next){
		if((listenfd = socket(p->ai_family,p->ai_socktype,p->ai_protocol))<0)
			continue;
		//允许端口复用
		Setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR,
						                    (const void*)&optval, sizeof(int));
		if(bind(listenfd, p->ai_addr, p->ai_addrlen) == 0)
			break;
		Close(listenfd);
	}
	
	Freeaddrinfo(listp);
	if(!p) return -1;
	if(listen(listenfd, LISTENQ) < 0){
		Close(listenfd);
		return -1;
	}
	return listenfd;
}
```
## 9. echo客户端和服务器的示例
客户端
```C
#include "csapp.h"

int main(int argc, char** argv)
{
	int clientfd;
	char *host, *port, buf[MAXLINE];
	rio_t rio;
	
	if(argc != 3){
		fprintf(stderr, "usage: %s <host> <post>\n", argv[0]);
		exit(0);
	}
	host = argv[1];
	port = argv[2];
	
	clientfd = Open_clientfd(host, port);
	Rio_readinitb(&rio, clientfd);
	
	while(Fgets(buf, MAXLINE, stdin) != NULL){
		//将刚读取到的文本发送给服务器
		Rio_writen(clientfd, buf, strlen(buf));   
		//从服务器读取一行回应并存回buf
		Rio_readlineb(&rio, buf, MAXLINE);
		//将buf内容打印到屏幕
		Fputs(buf, stdout);
	}
	Close(clientfd);
	exit(0);
}
```
服务器
```C
#include "csapp.h"

void echo(int connfd)
{
	size_t n;
	char buf[MAXLINE];
	rio_t rio;
	
	Rio_readinitb(&rio, connfd);
	while((n = Rio_readlineb(&rio, buf, MAXLINE)) != 0){
		printf("server received %d bytes\n", (int)n);
		//将接收到的内容原样返回给客户端
		Rio_writen(connfd, buf, n);
	}
}

int main(int argc, char** argv)
{
	int listenfd, connfd;
	socklen_t clientlen;
	struct sockaddr_storage clientaddr;
	char client_hostname[MAXLINE], client_port[MAXLINE];
	
	if(argc != 2){
		fprintf(stderr, "usage %s <port>\n", argv[0]);
		exit(0);
	}
	
	listenfd = Open_listenfd(argv[1]);
	while(1){
		clientlen = sizeof(struct sockaddr_storage);
		connfd = Accept(listenfd, (SA*)&clientaddr, &clientlen);
		Getnameinfo((SA*)&clientaddr, clientlen, client_hostname,
										MAXLINE, client_port, MAXLINE, 0);
		printf("Connected to (%s, %s)\n", client_hostname, client_port);
		echo(connfd);
		Close(connfd);
	}
	exit(0);
}
```
# 11.5 Web服务器
## 1. Web基础
- Web客户端与服务器之间的交互是通过HTTP协议（Hypertext Transfer Protocol）进行的。
- Web内容由HTML语言描述页面结构，配合CSS及JavaScript。
```html
<b> Make me bold! </b>
<a href = "http://www.cmu.edu/index.html"> Carnegie Mellon </a>
```
- Web与传统文件传输（FTP）的区别：
	- Web不仅支持传输静态文件，还能返回动态生成的内容（服务器在收到请求时才返回的数据）。
	- HTTP额外提供一些高级功能。
## 2. Web内容
### (1) 数据类型
- HTTP传输的本质：对于Web客户端和服务器而言，所谓的“内容”就是一串字节，但浏览器需要一个“类型标签”来正确处理和显示数据。这个标签就是MIME。

| MIME类型                 | 描述            |
| ---------------------- | ------------- |
| text/html              | HTML界面        |
| text/plain             | 无格式文本         |
| application/postscript | Postscript文档  |
| image/gif              | GIF格式编码的二进制图像 |
| image/png              | PNG格式         |
| image/jepg             | JEPG格式        |
### (2) 数据返回方式
1. 取磁盘文件并将其内容返回给客户端。
	- 磁盘文件称为静态内容（static content），返回文件给客户端的过程称为服务静态内容。
2. 运行可执行文件并将结果返回给客户端。
	- 输出为动态内容（dynamic content），过程称为服务动态内容。
### (3) URL
>URL（Uniform Resource Locator）就是Web上资源的地址，告诉浏览器去哪里找内容，以及用什么协议去访问。

基本结构：`scheme://host:port/path?query#fragment`
1. scheme（协议）：指定访问资源的协议，包括http，https等。
2. host（主机）：服务器地址，可以是域名或IP。
3. port（端口，可选）：服务器的端口号，如HTTP默认80。
4. path（路径）：服务器上资源的位置，如`/index.html`。
5. query（查询，可选）：传递给服务器的参数，格式是`key = value`，多个参数用`&`连接。
6. fragment（片段，可选）：文档内部位置，浏览器滚动到指定锚点，如`section1`。

示例：
```
https://www.cmu.edu:443/education/courses?term=fall2025#syllabus
```
## 3. HTTP事务

## 4. 服务动态内容
# 11.6 综合：TINY Web服务器

# 11.7 小结
