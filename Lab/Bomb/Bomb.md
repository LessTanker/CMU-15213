# phase_1

使用`gdb bomb`进入调试界面，新建`solu.txt`存储答案，允许我们每次运行不用反复输入已经通过的答案。通过`disas phase_1`反汇编得到汇编代码。

```asm
(gdb) disas phase_1
Dump of assembler code for function phase_1:
   0x0000000000400ee0 <+0>:     sub    $0x8,%rsp
   0x0000000000400ee4 <+4>:     mov    $0x402400,%esi
   0x0000000000400ee9 <+9>:     callq  0x401338 <strings_not_equal>
   0x0000000000400eee <+14>:    test   %eax,%eax
   0x0000000000400ef0 <+16>:    je     0x400ef7 <phase_1+23>
   0x0000000000400ef2 <+18>:    callq  0x40143a <explode_bomb>
   0x0000000000400ef7 <+23>:    add    $0x8,%rsp
   0x0000000000400efb <+27>:    retq
End of assembler dump.
```

这里`%esi`作为函数`strings_not_equal`调用的第二个参数，其值来自`0x402400`。而函数的第一个参数应该是我们输入的东西，在`phase_1`之前的代码已经实现，所以这段代码没有`scanf`的调用。

通过`x/s 0x402400`可以看到`%esi`存储的字符串为：

```asm
(gdb) x/s 0x402400
0x402400:       "Border relations with Canada have never been better."
```

这也就是我们第一道题的答案了，将其写入`solu.txt`即可。
# phase_2

```asm
(gdb) disas phase_2
Dump of assembler code for function phase_2:
   0x0000000000400efc <+0>:     push   %rbp
   0x0000000000400efd <+1>:     push   %rbx
   0x0000000000400efe <+2>:     sub    $0x28,%rsp
   0x0000000000400f02 <+6>:     mov    %rsp,%rsi
   0x0000000000400f05 <+9>:     callq  0x40145c <read_six_numbers>
   0x0000000000400f0a <+14>:    cmpl   $0x1,(%rsp)
   0x0000000000400f0e <+18>:    je     0x400f30 <phase_2+52>
   0x0000000000400f10 <+20>:    callq  0x40143a <explode_bomb>
   0x0000000000400f15 <+25>:    jmp    0x400f30 <phase_2+52>
   0x0000000000400f17 <+27>:    mov    -0x4(%rbx),%eax
   0x0000000000400f1a <+30>:    add    %eax,%eax
   0x0000000000400f1c <+32>:    cmp    %eax,(%rbx)
   0x0000000000400f1e <+34>:    je     0x400f25 <phase_2+41>
   0x0000000000400f20 <+36>:    callq  0x40143a <explode_bomb>
   0x0000000000400f25 <+41>:    add    $0x4,%rbx
   0x0000000000400f29 <+45>:    cmp    %rbp,%rbx
   0x0000000000400f2c <+48>:    jne    0x400f17 <phase_2+27>
   0x0000000000400f2e <+50>:    jmp    0x400f3c <phase_2+64>
   0x0000000000400f30 <+52>:    lea    0x4(%rsp),%rbx
   0x0000000000400f35 <+57>:    lea    0x18(%rsp),%rbp
   0x0000000000400f3a <+62>:    jmp    0x400f17 <phase_2+27>
   0x0000000000400f3c <+64>:    add    $0x28,%rsp
   0x0000000000400f40 <+68>:    pop    %rbx
   0x0000000000400f41 <+69>:    pop    %rbp
   0x0000000000400f42 <+70>:    retq
End of assembler dump.
```

在<+9>这里调用了函数`read_six_numbers`，说明这一关需要我们输入6个整数，并且它们会依次存放在栈上。紧接着在<+14>要求`(%rsp)`等于1。由于输入的数组首地址正好存在栈顶，所以这里实际上是要求第一个输入的数字为1。

在<+52>把数组的第二个元素`0x4(%rsp)`存入`%rbx`，同时把数组末尾`0x18(%rsp)`存入`%rbp`，作为循环的终止条件。然后跳转到<+27>开始循环。

在<+27>~<+32>先取出前一个元素，乘以2，再和当前元素比较。如果不相等，就会调用`explode_bomb`。这就要求每一个元素必须等于前一个元素的两倍。

在<+41>`%rbx`移动到下一个元素，继续循环，直到遍历完整个数组为止。因此可以得出结论：一共要输入 6 个整数，第一个数必须是1，之后每一个数都是前一个数的两倍。最终答案为：`1 2 4 8 16 32`
# phase_3

```asm
(gdb) disas phase_3
Dump of assembler code for function phase_3:
   0x0000000000400f43 <+0>:     sub    $0x18,%rsp
   0x0000000000400f47 <+4>:     lea    0xc(%rsp),%rcx
   0x0000000000400f4c <+9>:     lea    0x8(%rsp),%rdx
   0x0000000000400f51 <+14>:    mov    $0x4025cf,%esi
   0x0000000000400f56 <+19>:    mov    $0x0,%eax
   0x0000000000400f5b <+24>:    callq  0x400bf0 <__isoc99_sscanf@plt>
   0x0000000000400f60 <+29>:    cmp    $0x1,%eax
   0x0000000000400f63 <+32>:    jg     0x400f6a <phase_3+39>
   0x0000000000400f65 <+34>:    callq  0x40143a <explode_bomb>
   0x0000000000400f6a <+39>:    cmpl   $0x7,0x8(%rsp)
   0x0000000000400f6f <+44>:    ja     0x400fad <phase_3+106>
   0x0000000000400f71 <+46>:    mov    0x8(%rsp),%eax
   0x0000000000400f75 <+50>:    jmpq   *0x402470(,%rax,8)
   0x0000000000400f7c <+57>:    mov    $0xcf,%eax
   0x0000000000400f81 <+62>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f83 <+64>:    mov    $0x2c3,%eax
   0x0000000000400f88 <+69>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f8a <+71>:    mov    $0x100,%eax
   0x0000000000400f8f <+76>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f91 <+78>:    mov    $0x185,%eax
   0x0000000000400f96 <+83>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f98 <+85>:    mov    $0xce,%eax
   0x0000000000400f9d <+90>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f9f <+92>:    mov    $0x2aa,%eax
   0x0000000000400fa4 <+97>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400fa6 <+99>:    mov    $0x147,%eax
   0x0000000000400fab <+104>:   jmp    0x400fbe <phase_3+123>
   0x0000000000400fad <+106>:   callq  0x40143a <explode_bomb>
   0x0000000000400fb2 <+111>:   mov    $0x0,%eax
   0x0000000000400fb7 <+116>:   jmp    0x400fbe <phase_3+123>
   0x0000000000400fb9 <+118>:   mov    $0x137,%eax
   0x0000000000400fbe <+123>:   cmp    0xc(%rsp),%eax
   0x0000000000400fc2 <+127>:   je     0x400fc9 <phase_3+134>
   0x0000000000400fc4 <+129>:   callq  0x40143a <explode_bomb>
   0x0000000000400fc9 <+134>:   add    $0x18,%rsp
   0x0000000000400fcd <+138>:   retq
End of assembler dump.
```

在<+14>我们发现汇编代码将某个地址的值放入了`%esi`作为调用函数`sscanf`的第二个参数，所以我们通过`x/s 0x4025cf`查看其值：

```asm
(gdb) x/s 0x4025cf
0x4025cf:       "%d %d"
```

从这里我们得到这道题目需要我们输入两个整数。再结合<+4>和<+9>我们就得知这两个数已经存储在`%rdx`和`%rcx`。

之后来到<+50>，`*0x402470(,%rax,8)`是一个标准的跳转表的格式，我们完全可以猜测出来这是一个`switch`语句。而`%rax`（我们输入的第一个数，在<+46>被传入）就是索引。我们通过指令`x/8gx 0x402470`查看其附近的信息：

```asm
(gdb) x/8gx 0x402470
0x402470:       0x0000000000400f7c      0x0000000000400fb9
0x402480:       0x0000000000400f83      0x0000000000400f8a
0x402490:       0x0000000000400f91      0x0000000000400f98
0x4024a0:       0x0000000000400f9f      0x0000000000400fa6
```

发现正好对应下面<+57>~<+116>的地址，这里我们第一个数输入2的话对应的是<+64>的地址，结合后面<+123>检查第二个数和跳转表里的数是否相等，所以我们第二个数应该输入跳转表里面的数字`2c3`，即其中一种正确答案是`2 707`。
# phase_4

```asm
(gdb) disas phase_4
Dump of assembler code for function phase_4:
   0x000000000040100c <+0>:     sub    $0x18,%rsp
   0x0000000000401010 <+4>:     lea    0xc(%rsp),%rcx
   0x0000000000401015 <+9>:     lea    0x8(%rsp),%rdx
   0x000000000040101a <+14>:    mov    $0x4025cf,%esi
   0x000000000040101f <+19>:    mov    $0x0,%eax
   0x0000000000401024 <+24>:    callq  0x400bf0 <__isoc99_sscanf@plt>
   0x0000000000401029 <+29>:    cmp    $0x2,%eax
   0x000000000040102c <+32>:    jne    0x401035 <phase_4+41>
   0x000000000040102e <+34>:    cmpl   $0xe,0x8(%rsp)
   0x0000000000401033 <+39>:    jbe    0x40103a <phase_4+46>
   0x0000000000401035 <+41>:    callq  0x40143a <explode_bomb>
   0x000000000040103a <+46>:    mov    $0xe,%edx
   0x000000000040103f <+51>:    mov    $0x0,%esi
   0x0000000000401044 <+56>:    mov    0x8(%rsp),%edi
   0x0000000000401048 <+60>:    callq  0x400fce <func4>
   0x000000000040104d <+65>:    test   %eax,%eax
   0x000000000040104f <+67>:    jne    0x401058 <phase_4+76>
   0x0000000000401051 <+69>:    cmpl   $0x0,0xc(%rsp)
   0x0000000000401056 <+74>:    je     0x40105d <phase_4+81>
   0x0000000000401058 <+76>:    callq  0x40143a <explode_bomb>
   0x000000000040105d <+81>:    add    $0x18,%rsp
   0x0000000000401061 <+85>:    retq
End of assembler dump.
```

 与上一道题目一致，这道题也需要我们输入两个整数，不同的是，在<+46>~<+56>这里将第一个整数作为第一个参数，0作为第二个参数，14作为第三个参数传入函数`func4`。而后检测其输出是否为0，如果不为零则调用函数`explode_bomb`。同时<+69>要求输入的第二个数必须是0。下面来看`func4`的功能：

```asm
(gdb) disas func4
Dump of assembler code for function func4:
   0x0000000000400fce <+0>:     sub    $0x8,%rsp
   0x0000000000400fd2 <+4>:     mov    %edx,%eax
   0x0000000000400fd4 <+6>:     sub    %esi,%eax
   0x0000000000400fd6 <+8>:     mov    %eax,%ecx
   0x0000000000400fd8 <+10>:    shr    $0x1f,%ecx
   0x0000000000400fdb <+13>:    add    %ecx,%eax
   0x0000000000400fdd <+15>:    sar    %eax
   0x0000000000400fdf <+17>:    lea    (%rax,%rsi,1),%ecx
   0x0000000000400fe2 <+20>:    cmp    %edi,%ecx
   0x0000000000400fe4 <+22>:    jle    0x400ff2 <func4+36>
   0x0000000000400fe6 <+24>:    lea    -0x1(%rcx),%edx
   0x0000000000400fe9 <+27>:    callq  0x400fce <func4>
   0x0000000000400fee <+32>:    add    %eax,%eax
   0x0000000000400ff0 <+34>:    jmp    0x401007 <func4+57>
   0x0000000000400ff2 <+36>:    mov    $0x0,%eax
   0x0000000000400ff7 <+41>:    cmp    %edi,%ecx
   0x0000000000400ff9 <+43>:    jge    0x401007 <func4+57>
   0x0000000000400ffb <+45>:    lea    0x1(%rcx),%esi
   0x0000000000400ffe <+48>:    callq  0x400fce <func4>
   0x0000000000401003 <+53>:    lea    0x1(%rax,%rax,1),%eax
   0x0000000000401007 <+57>:    add    $0x8,%rsp
   0x000000000040100b <+61>:    retq
End of assembler dump.
```

这段函数本质上是在进行二分查找，从<+4>~<+17>进行的操作是寻找`%edx`和`%esi`的中点并存进`%ecx`，<+10>和<+13>是在处理负数的情况。

如果传入值大于中点，则执行<+24>递归调用函数`func4(x, low, mid-1)`，结果为`2 * result`。而如果小于等于中点，就执行<36>的指令。如果恰好等于中点，则函数结束，返回0。否则调用函数`func4(x, mid+1, high)`，结果为`2 * result + 1`。

类似的C语言源码可能为：
```C
int func4(int x, int low, int high)
{
    // mid = (low + high) / 2 （做了防溢出处理，但这里直接写）
    int mid = low + (high - low) / 2;
    if (x == mid) 
        return 0;
    else if (x < mid) 
        return 2 * func4(x, mid + 1, high) + 1;
    else
        return 2 * func4(x, low, mid - 1);
}
```

所以这里我们的答案可以是`7 0`或者`0 0`。
# phase_5

## 1. 输入判断

```asm
(gdb) disas phase_5
Dump of assembler code for function phase_5:
=> 0x0000000000401062 <+0>:     push   %rbx
   0x0000000000401063 <+1>:     sub    $0x20,%rsp
   0x0000000000401067 <+5>:     mov    %rdi,%rbx
   0x000000000040106a <+8>:     mov    %fs:0x28,%rax
   0x0000000000401073 <+17>:    mov    %rax,0x18(%rsp)
   0x0000000000401078 <+22>:    xor    %eax,%eax
   0x000000000040107a <+24>:    callq  0x40131b <string_length>
   0x000000000040107f <+29>:    cmp    $0x6,%eax
   0x0000000000401082 <+32>:    je     0x4010d2 <phase_5+112>
   0x0000000000401084 <+34>:    callq  0x40143a <explode_bomb>
   0x0000000000401089 <+39>:    jmp    0x4010d2 <phase_5+112>
```

在<+5>这里将我们的输入从`%rdi`移动到`%rbx`准备后续使用。

在<+8>`mov %fs:0x28, %rax`的含义是将canary值放入`%rax`中来防止代码被恶意攻击。这里`%fs:0x28`就是专门用来存储canary的。

在<+24> 这里可以看到调用了一个名称为`string_length`的函数，将返回的结果存储在`%eax`中并与6比较，如果不相等则调用`explode_bomb`。从这里可以知道这道题需要我们输入长度为6的字符串。随后函数跳转到<+112>。

```asm
   0x00000000004010d2 <+112>:   mov    $0x0,%eax
   0x00000000004010d7 <+117>:   jmp    0x40108b <phase_5+41>
```
这里就是很简单的将`%eax`归零，并再次跳转到<+41>。
## 2. 字符串替换

```asm
   0x000000000040108b <+41>:    movzbl (%rbx,%rax,1),%ecx
   0x000000000040108f <+45>:    mov    %cl,(%rsp)
   0x0000000000401092 <+48>:    mov    (%rsp),%rdx
   0x0000000000401096 <+52>:    and    $0xf,%edx
   0x0000000000401099 <+55>:    movzbl 0x4024b0(%rdx),%edx
   0x00000000004010a0 <+62>:    mov    %dl,0x10(%rsp,%rax,1)
   0x00000000004010a4 <+66>:    add    $0x1,%rax
   0x00000000004010a8 <+70>:    cmp    $0x6,%rax
   0x00000000004010ac <+74>:    jne    0x40108b <phase_5+41>
```

 <+41>里的`movzbl`指令是转移后将目的寄存器的低8位保留，高24位清零。该指令要求源操作数只有8位。`(%rbx, %rax, 1)`表示寻址到内存`%rbx+1*%rax`处的一个字节。前面提到`%rbx`就是我们的输入字符串，而`%rax`在<+112>处被置零，所以这里实际上是把我们输入的第一个8字节字符保存到`%ecx`寄存器中。

随后<+45><+48>两条指令将我们刚得到的字符传入`%rdx`中准备使用，这里`%cl`就是`%ecx`的低8位。

<+52>这里将`%edx`与常数`0xf`做与运算，当前`edx`的高24位为0，低8位存储我们输入的字符的ASCII编码表示。而与运算得到的结果就是`edx`的低4位值。我们稍后就要使用这个范围是0~15的值来查表。

<+55>这条指令是说将我们刚得到的那个0~15的值作为地址`0x4024b0`的偏移量，并将偏移后所在地址存储的内容放回`%edx`中备用。在这里我们通过gdb指令`x/16xb 0x4024b0`可以看到以`0x4024b0`作为首地址的16字节的数据（以十六进制存储）。

```asm
(gdb) x/16xb 0x4024b0
0x4024b0 <array.3449>:      0x6d 0x61  0x64 0x75  0x69 0x65 0x72 0x73
0x4024b8 <array.3449+8>:  0x6e 0x66 0x6f 0x74  0x76 0x62  0x79  0x6c
```
这张表格就是我们稍后获取答案的关键。

而后<+66><+70>这两条指令可以看出来是一个循环条件，检测`%rax`存储的值是否达到6，如果没有就重新进入循环。这也符合对输入的6个字符循环6次进行处理的逻辑。
## 3. 检测输出

在这里我们还不知道题目到底需要我们做什么，接着看汇编代码：
```asm
   0x00000000004010ae <+76>:    movb   $0x0,0x16(%rsp)
   0x00000000004010b3 <+81>:    mov    $0x40245e,%esi
   0x00000000004010b8 <+86>:    lea    0x10(%rsp),%rdi
   0x00000000004010bd <+91>:    callq  0x401338 <strings_not_equal>
   0x00000000004010c2 <+96>:    test   %eax,%eax
   0x00000000004010c4 <+98>:    je     0x4010d9 <phase_5+119>
   0x00000000004010c6 <+100>:   callq  0x40143a <explode_bomb>
```

<+81>这里将地址`0x40245e`内存储的值放进`%esi`中，我们发现<+91>这里调用了一个名字叫做`strings_not_equal`的函数，所以不妨大胆猜测`esi`作为该函数的第二个参数是一个字符串，我们通过`x/s 0x40245e`发现里面存储的字符串是`flyers`。而函数的第一个参数`%rdi`在<+62>这里可以发现是我们输入的字符串经过处理后得到的新的字符串。

再结合<+96><+98><+100>，需要我们做的已经很清晰了：
找到一个包含6个字符的字符串，使其在经过一个特定的处理后，变成flyers这个字符串！！

再回到刚才的表格，为便于阅读，我将汇编代码和表格重新放出来。
```asm
   0x000000000040108b <+41>:    movzbl (%rbx,%rax,1),%ecx
   0x000000000040108f <+45>:    mov    %cl,(%rsp)
   0x0000000000401092 <+48>:    mov    (%rsp),%rdx
   0x0000000000401096 <+52>:    and    $0xf,%edx
   0x0000000000401099 <+55>:    movzbl 0x4024b0(%rdx),%edx
   0x00000000004010a0 <+62>:    mov    %dl,0x10(%rsp,%rax,1)
   0x00000000004010a4 <+66>:    add    $0x1,%rax
   0x00000000004010a8 <+70>:    cmp    $0x6,%rax
   0x00000000004010ac <+74>:    jne    0x40108b <phase_5+41>
```

```asm
(gdb) x/16xb 0x4024b0
0x4024b0 <array.3449>:      0x6d 0x61  0x64 0x75  0x69 0x65 0x72 0x73
0x4024b8 <array.3449+8>:  0x6e 0x66 0x6f 0x74  0x76 0x62  0x79  0x6c
```

我们这里以第一个要转换出来的字符"f"为例，通过查询ASCII表可以知道"f"的值以十六进制表示为66，而我们发现在上面的表格中刚好有0x66这个值！

在<+55>这里我们知道我们输入的字符的后四位是作为偏移量存在的，所以我们要计算的就是`0x4024b0`到我们需要的0x66的偏移量。而这里显然是9（从0开始，比如0x6d需要的偏移量是0，因为地址0x4024b0存储的字节就是0x6d)。

再返回ASCII表，这次我们需要的是十六进制表示下后四位为1001（即9）的字符，发现"i"和"y"这两个字符都满足条件，所以我们知道了我们要输入的第一个字符可以是"i"或者"y"！！

通过这样的操作重复6次，我们就可以得到正确的输入，从而破解这个bomb。
# phase_6
## 1. 输入检测

```asm
   0x00000000004010f4 <+0>:     push   %r14
   0x00000000004010f6 <+2>:     push   %r13
   0x00000000004010f8 <+4>:     push   %r12
   0x00000000004010fa <+6>:     push   %rbp
   0x00000000004010fb <+7>:     push   %rbx
   0x00000000004010fc <+8>:     sub    $0x50,%rsp
   0x0000000000401100 <+12>:    mov    %rsp,%r13
   0x0000000000401103 <+15>:    mov    %rsp,%rsi
   0x0000000000401106 <+18>:    callq  0x40145c <read_six_numbers>
```

首先在<+15>这里将栈顶地址存给`%rsi`作为函数调用的第二个参数，而后<+18>调用了一个叫做`read_six_numbers`的函数，我们可以通过`disas read_six_numbers`反汇编该函数得到这道题需要的输入形式：6个整数。

```asm
(gdb) disas read_six_numbers
Dump of assembler code for function read_six_numbers:
   0x000000000040145c <+0>:     sub    $0x18,%rsp
   0x0000000000401460 <+4>:     mov    %rsi,%rdx
   0x0000000000401463 <+7>:     lea    0x4(%rsi),%rcx
   0x0000000000401467 <+11>:    lea    0x14(%rsi),%rax
   0x000000000040146b <+15>:    mov    %rax,0x8(%rsp)
   0x0000000000401470 <+20>:    lea    0x10(%rsi),%rax
   0x0000000000401474 <+24>:    mov    %rax,(%rsp)
   0x0000000000401478 <+28>:    lea    0xc(%rsi),%r9
   0x000000000040147c <+32>:    lea    0x8(%rsi),%r8
   0x0000000000401480 <+36>:    mov    $0x4025c3,%esi
   0x0000000000401485 <+41>:    mov    $0x0,%eax
   0x000000000040148a <+46>:    callq  0x400bf0 <__isoc99_sscanf@plt>
   0x000000000040148f <+51>:    cmp    $0x5,%eax
   0x0000000000401492 <+54>:    jg     0x401499 <read_six_numbers+61>
   0x0000000000401494 <+56>:    callq  0x40143a <explode_bomb>
   0x0000000000401499 <+61>:    add    $0x18,%rsp
   0x000000000040149d <+65>:    retq
End of assembler dump.
```

从<+7>~<+32>这些代码其实是为调用`sscanf`函数准备参数，我们可以通过`x/s 0x4025c3`查看其存储内容，发现为`"%d %d %d %d %d %d"`。这里就可以确定这道题确实需要我们输入六个整数，同时从原函数<+15>知道该数组的首地址存储在栈顶。
## 2. 合法性检查

```asm
   0x000000000040110b <+23>:    mov    %rsp,%r14
   0x000000000040110e <+26>:    mov    $0x0,%r12d
   0x0000000000401114 <+32>:    mov    %r13,%rbp
   0x0000000000401117 <+35>:    mov    0x0(%r13),%eax
   0x000000000040111b <+39>:    sub    $0x1,%eax
   0x000000000040111e <+42>:    cmp    $0x5,%eax
   0x0000000000401121 <+45>:    jbe    0x401128 <phase_6+52>
   0x0000000000401123 <+47>:    callq  0x40143a <explode_bomb>
   0x0000000000401128 <+52>:    add    $0x1,%r12d
   0x000000000040112c <+56>:    cmp    $0x6,%r12d
   0x0000000000401130 <+60>:    je     0x401153 <phase_6+95>
   0x0000000000401132 <+62>:    mov    %r12d,%ebx
   0x0000000000401135 <+65>:    movslq %ebx,%rax
   0x0000000000401138 <+68>:    mov    (%rsp,%rax,4),%eax
   0x000000000040113b <+71>:    cmp    %eax,0x0(%rbp)
   0x000000000040113e <+74>:    jne    0x401145 <phase_6+81>
   0x0000000000401140 <+76>:    callq  0x40143a <explode_bomb>
   0x0000000000401145 <+81>:    add    $0x1,%ebx
   0x0000000000401148 <+84>:    cmp    $0x5,%ebx
   0x000000000040114b <+87>:    jle    0x401135 <phase_6+65>
   0x000000000040114d <+89>:    add    $0x4,%r13
   0x0000000000401151 <+93>:    jmp    0x401114 <phase_6+32>
```

截止到<+32>，我们可以看到`%r13`、`%r14`、`%rbp`这三个寄存器都保存了输入数组的首地址。<+35> 表明 `%eax` 存储了数组的第一个元素，而<+39>~<+47> 的指令要求这个首元素必须小于等于6，否则会调用`explode_bomb`。

在<+52>，`%r12d`很可能作为循环变量使用，因为紧接着<+56> 就将其与 6 进行比较判断。进入循环后，`%rax`被设置为`%r12d`的值，然后通过`(%rsp,%rax,4)`访问栈上数组的第i个元素，将其存入`%eax`。随后，该元素会与数组首元素进行比较，如果相等则触发`explode_bomb`，否则继续循环（跳转到<+81>）。

<+81>~<+87>与<+39>~<+45> 的逻辑类似，用于对循环中的元素进行值的范围检测（确保小于等于 6）。在<+93>，循环回到<+32>，开始下一轮外层循环。

通过以上分析，可以总结出输入数组的约束条件：
1. 每个元素必须小于等于6（汇编直接检测了`>6`的情况）；
2. 元素之间不能相等（重复会触发 `explode_bomb`）；
3. 虽然`<1`的检查没有在这一段直接出现，但结合后续构造链表和索引访问的汇编逻辑可以推测，如果输入小于 1 会导致数组越界或访问非法地址，从而间接触发爆炸。

因此，可以推测这道题要求输入1~6 的六个整数的某种排列，即每个数字都在 1~6 之间且互不重复。

其对应的C语言源码大致是这个样子的：
```C
void phase_6(int *input)
{
	......
	if (input[0] > 6)
        explode_bomb();
    for (i = 0; i < 6; i++) {
        if (input[i] > 6)
            explode_bomb();
        for (j = 0; j < i; j++) {
            if (input[i] == input[j])
                explode_bomb();
        }
    }
    ......
}
```
## 3. 数组映射

```asm
   0x0000000000401153 <+95>:    lea    0x18(%rsp),%rsi
   0x0000000000401158 <+100>:   mov    %r14,%rax
   0x000000000040115b <+103>:   mov    $0x7,%ecx
   0x0000000000401160 <+108>:   mov    %ecx,%edx
   0x0000000000401162 <+110>:   sub    (%rax),%edx
   0x0000000000401164 <+112>:   mov    %edx,(%rax)
   0x0000000000401166 <+114>:   add    $0x4,%rax
   0x000000000040116a <+118>:   cmp    %rsi,%rax
   0x000000000040116d <+121>:   jne    0x401160 <phase_6+108>
   0x000000000040116f <+123>:   mov    $0x0,%esi
   0x0000000000401174 <+128>:   jmp    0x401197 <phase_6+163>
```

<+95>将`%rsp+0x18`放入`%rsi`中，这个地址对应的是数组的末地址（$(18)_{16}=(24)_{10}$）。结合<+118>这里的`cmp`指令可以猜测这又是一个循环，`%rsi`作为循环终止条件出现。

<+108>~<+121>这里的汇编代码并不难读，就是遍历数组的每个元素，将其值用7去减，做了一次映射。比如输入`5 4 2 3 1 6`就会映射为`2 3 5 4 6 1`。
## 4. 对应链表

```asm
   0x0000000000401176 <+130>:   mov    0x8(%rdx),%rdx
   0x000000000040117a <+134>:   add    $0x1,%eax
   0x000000000040117d <+137>:   cmp    %ecx,%eax
   0x000000000040117f <+139>:   jne    0x401176 <phase_6+130>
   0x0000000000401181 <+141>:   jmp    0x401188 <phase_6+148>
   0x0000000000401183 <+143>:   mov    $0x6032d0,%edx
   0x0000000000401188 <+148>:   mov    %rdx,0x20(%rsp,%rsi,2)
   0x000000000040118d <+153>:   add    $0x4,%rsi
   0x0000000000401191 <+157>:   cmp    $0x18,%rsi
   0x0000000000401195 <+161>:   je     0x4011ab <phase_6+183>
   0x0000000000401197 <+163>:   mov    (%rsp,%rsi,1),%ecx
   0x000000000040119a <+166>:   cmp    $0x1,%ecx
   0x000000000040119d <+169>:   jle    0x401183 <phase_6+143>
   0x000000000040119f <+171>:   mov    $0x1,%eax
   0x00000000004011a4 <+176>:   mov    $0x6032d0,%edx
   0x00000000004011a9 <+181>:   jmp    0x401176 <phase_6+130>
```

这段代码是`phase_6`的关键点，也是整个Bomb实验最难的部分（大概吧）。先说这段代码是做什么的，然后再对照汇编代码理解。

在`phase_6`这个函数中维护了一个首元素地址为`0x6032d0`的链表，链表中的每个节点包含以下信息：存储的值，指向下一节点的指针，用于记录节点所在位置的索引。这段代码实际做的是：循环读取之前得到的数组的每个元素，按照其值找到链表中对应索引的节点，并将该节点存储的值存放到另一个数组上。

例如，假如我们上一步得到的数组的首元素是3，那么链表就从头节点移动2步找到第三个节点，并读取该节点存储的值，然后将该值存放为另一个数组的首元素。

<+130>的指令实际上就是从链表的当前节点找到下一个节点。而后<+134>~<+139>用于内层循环变量，统计本轮应该应该移动多少步才能找到目标节点。
在<+148>这里我们发现其将获取的值存放到了`0x20(%rsp, %rsi, 2)`这个目标地址上，这也就是结果数组的地址。即存放地址为`%rsp+0x20`,`%rsp+0x28`,$\cdots$,`%rsp+44`。

在<+143>这里的`0x6032d0`就是链表的首地址，我们可以通过指令`x/24wx 0x6032d0`看到这个链表头节点附近都存储了什么。

```asm
(gdb) x/24wx 0x6032d0
0x6032d0 <node1>:   0x0000014c   0x00000001    0x006032e0    0x00000000
0x6032e0 <node2>:   0x000000a8   0x00000002    0x006032f0   0x00000000
0x6032f0 <node3>:   0x0000039c   0x00000003    0x00603300   0x00000000
0x603300 <node4>:   0x000002b3   0x00000004   0x00603310    0x00000000
0x603310 <node5>:   0x000001dd   0x00000005    0x00603320    0x00000000
0x603320 <node6>:   0x000001bb   0x00000006    0x00000000    0x00000000
```

可以发现这6个节点的地址是邻接的，而`14c`,`0a8`这些就是链表存储的值。第三列存储的可以发现就是下一节点的地址。

综上，如果我输入的数组的第一个值是3，首先做一次映射变成4，而后通过链表找到对应的节点`node4`存储的值`0x000002b3`，然后将这个值存储到`%rsp+0x20`上面，再循环处理数组的其他元素直到得到完整的结果数组。
## 5. 输出检测

```asm
   0x00000000004011ab <+183>:   mov    0x20(%rsp),%rbx
   0x00000000004011b0 <+188>:   lea    0x28(%rsp),%rax
   0x00000000004011b5 <+193>:   lea    0x50(%rsp),%rsi
   0x00000000004011ba <+198>:   mov    %rbx,%rcx
   0x00000000004011bd <+201>:   mov    (%rax),%rdx
   0x00000000004011c0 <+204>:   mov    %rdx,0x8(%rcx)
   0x00000000004011c4 <+208>:   add    $0x8,%rax
   0x00000000004011c8 <+212>:   cmp    %rsi,%rax
   0x00000000004011cb <+215>:   je     0x4011d2 <phase_6+222>
   0x00000000004011cd <+217>:   mov    %rdx,%rcx
   0x00000000004011d0 <+220>:   jmp    0x4011bd <phase_6+201>
   0x00000000004011d2 <+222>:   movq   $0x0,0x8(%rdx)
   0x00000000004011da <+230>:   mov    $0x5,%ebp
   0x00000000004011df <+235>:   mov    0x8(%rbx),%rax
   0x00000000004011e3 <+239>:   mov    (%rax),%eax
   0x00000000004011e5 <+241>:   cmp    %eax,(%rbx)
   0x00000000004011e7 <+243>:   jge    0x4011ee <phase_6+250>
   0x00000000004011e9 <+245>:   callq  0x40143a <explode_bomb>
   0x00000000004011ee <+250>:   mov    0x8(%rbx),%rbx
   0x00000000004011f2 <+254>:   sub    $0x1,%ebp
   0x00000000004011f5 <+257>:   jne    0x4011df <phase_6+235>
```

在 <+183>，程序先取出我们输入转换后的第一个节点地址，把它当作链表的起点。接下来它依次处理剩下的几个地址，把它们一个个接到链表后面，直到六个节点都串起来，并在最后一个节点的`next`位置写入空指针，形成一个完整的链表。

到了 <+230>，程序开始检查链表是否满足条件。它准备做 5 次比较，每次取当前节点和下一个节点的值进行检查。如果发现当前节点的值比后一个节点小，就会立刻触发`explode_bomb`。否则继续向后遍历，直到把所有节点都检查完。

因此，这一段代码的作用可以总结为：
1. 根据输入重新拼接链表。
2. 要求链表中的节点值必须是非递增的顺序排列，否则程序会爆炸。

到了这里，我们便可以得知我们需要输入的6位整数排列应该为`4 3 2 1 6 5`。
## 6. 函数返回

```   
   0x00000000004011f7 <+259>:   add    $0x50,%rsp
   0x00000000004011fb <+263>:   pop    %rbx
   0x00000000004011fc <+264>:   pop    %rbp
   0x00000000004011fd <+265>:   pop    %r12
   0x00000000004011ff <+267>:   pop    %r13
   0x0000000000401201 <+269>:   pop    %r14
   0x0000000000401203 <+271>:   retq
```

# 答案汇总

```txt
Border relations with Canada have never been better.
1 2 4 8 16 32
2 707
0 0
yonuvw
4 3 2 1 6 5
```

```asm
root@384ad3e1766c:~/CMU-15213/Lab/Bomb# ./bomb solu.txt
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Phase 1 defused. How about the next one?
That's number 2.  Keep going!
Halfway there!
So you got that one.  Try this one.
Good work!  On to the next...
Congratulations! You've defused the bomb!
```

至此我们就拆解了所有的炸弹，也完成了这个实验。